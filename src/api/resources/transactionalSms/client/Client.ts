// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as BrevoApi from "../../../index.js";

export declare namespace TransactionalSmsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class TransactionalSmsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<TransactionalSmsClient.Options>;

    constructor(options: TransactionalSmsClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * <Note>
     * If the user includes stop code in the Transactional SMS, then it will be switched to Marketing SMS automatically and it will be interpreted as a Marketing SMS. To send Transactional SMS as Transactional, it is important not to use stop code.
     *
     * Note: For adding a stop code, client has to add reply STOP to [STOP_CODE] and the [STOP_CODE] will be replaced with the number.
     * </Note>
     *
     * <Note title="For end users in France">
     * Transactional SMS can be sent at any time without time restrictions. However, if a message is categorized as Marketing, it must adhere to specific time restrictions. Messages sent outside of these restricted hours will experience delays and will be processed during allowable times. Specifically, Marketing SMS cannot be processed between 10pm and 8am, on Sundays, and on French public holidays.
     * </Note>
     *
     * @param {BrevoApi.SendTransacSms} request
     * @param {TransactionalSmsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrevoApi.BadRequestError}
     *
     * @example
     *     await client.transactionalSms.sendAsyncTransactionalSms({
     *         recipient: "33689965433",
     *         sender: "MyShop"
     *     })
     */
    public sendAsyncTransactionalSms(
        request: BrevoApi.SendTransacSms,
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): core.HttpResponsePromise<BrevoApi.SendAsyncTransactionalSmsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendAsyncTransactionalSms(request, requestOptions));
    }

    private async __sendAsyncTransactionalSms(
        request: BrevoApi.SendTransacSms,
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): Promise<core.WithRawResponse<BrevoApi.SendAsyncTransactionalSmsResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.BrevoApiEnvironment.Default,
                "transactionalSMS/send",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as BrevoApi.SendAsyncTransactionalSmsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new BrevoApi.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.BrevoApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/transactionalSMS/send");
    }

    /**
     * @param {BrevoApi.SendTransacSms} request
     * @param {TransactionalSmsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrevoApi.BadRequestError}
     * @throws {@link BrevoApi.PaymentRequiredError}
     *
     * @example
     *     await client.transactionalSms.sendTransacSms({
     *         recipient: "33689965433",
     *         sender: "MyShop"
     *     })
     */
    public sendTransacSms(
        request: BrevoApi.SendTransacSms,
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): core.HttpResponsePromise<BrevoApi.SendTransacSmsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendTransacSms(request, requestOptions));
    }

    private async __sendTransacSms(
        request: BrevoApi.SendTransacSms,
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): Promise<core.WithRawResponse<BrevoApi.SendTransacSmsResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.BrevoApiEnvironment.Default,
                "transactionalSMS/sms",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as BrevoApi.SendTransacSmsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new BrevoApi.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new BrevoApi.PaymentRequiredError(
                        _response.error.body as BrevoApi.ErrorModel,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.BrevoApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/transactionalSMS/sms");
    }

    /**
     * @param {BrevoApi.GetTransacAggregatedSmsReportRequest} request
     * @param {TransactionalSmsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrevoApi.BadRequestError}
     *
     * @example
     *     await client.transactionalSms.getTransacAggregatedSmsReport()
     */
    public getTransacAggregatedSmsReport(
        request: BrevoApi.GetTransacAggregatedSmsReportRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): core.HttpResponsePromise<BrevoApi.GetTransacAggregatedSmsReportResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getTransacAggregatedSmsReport(request, requestOptions));
    }

    private async __getTransacAggregatedSmsReport(
        request: BrevoApi.GetTransacAggregatedSmsReportRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): Promise<core.WithRawResponse<BrevoApi.GetTransacAggregatedSmsReportResponse>> {
        const { startDate, endDate, days, tag } = request;
        const _queryParams: Record<string, unknown> = {
            startDate,
            endDate,
            days,
            tag,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.BrevoApiEnvironment.Default,
                "transactionalSMS/statistics/aggregatedReport",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as BrevoApi.GetTransacAggregatedSmsReportResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new BrevoApi.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.BrevoApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/transactionalSMS/statistics/aggregatedReport",
        );
    }

    /**
     * @param {BrevoApi.GetSmsEventsRequest} request
     * @param {TransactionalSmsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrevoApi.BadRequestError}
     *
     * @example
     *     await client.transactionalSms.getSmsEvents()
     */
    public getSmsEvents(
        request: BrevoApi.GetSmsEventsRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): core.HttpResponsePromise<BrevoApi.GetSmsEventsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getSmsEvents(request, requestOptions));
    }

    private async __getSmsEvents(
        request: BrevoApi.GetSmsEventsRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): Promise<core.WithRawResponse<BrevoApi.GetSmsEventsResponse>> {
        const { limit, startDate, endDate, offset, days, phoneNumber, event, tags, sort } = request;
        const _queryParams: Record<string, unknown> = {
            limit,
            startDate,
            endDate,
            offset,
            days,
            phoneNumber,
            event: event != null ? event : undefined,
            tags,
            sort: sort != null ? sort : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.BrevoApiEnvironment.Default,
                "transactionalSMS/statistics/events",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as BrevoApi.GetSmsEventsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new BrevoApi.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.BrevoApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/transactionalSMS/statistics/events",
        );
    }

    /**
     * @param {BrevoApi.GetTransacSmsReportRequest} request
     * @param {TransactionalSmsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrevoApi.BadRequestError}
     *
     * @example
     *     await client.transactionalSms.getTransacSmsReport()
     */
    public getTransacSmsReport(
        request: BrevoApi.GetTransacSmsReportRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): core.HttpResponsePromise<BrevoApi.GetTransacSmsReportResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getTransacSmsReport(request, requestOptions));
    }

    private async __getTransacSmsReport(
        request: BrevoApi.GetTransacSmsReportRequest = {},
        requestOptions?: TransactionalSmsClient.RequestOptions,
    ): Promise<core.WithRawResponse<BrevoApi.GetTransacSmsReportResponse>> {
        const { startDate, endDate, days, tag, sort } = request;
        const _queryParams: Record<string, unknown> = {
            startDate,
            endDate,
            days,
            tag,
            sort: sort != null ? sort : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.BrevoApiEnvironment.Default,
                "transactionalSMS/statistics/reports",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as BrevoApi.GetTransacSmsReportResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new BrevoApi.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.BrevoApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/transactionalSMS/statistics/reports",
        );
    }
}
